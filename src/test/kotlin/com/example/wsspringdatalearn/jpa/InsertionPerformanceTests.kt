package com.example.wsspringdatalearn.jpa

import org.junit.jupiter.api.Test
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.TestPropertySource

const val NUMBER_OF_STOCKS = 10_000

@SpringBootTest
class InsertionPerformanceNoBatching : BaseTestSetup() {
    @Test
    fun regularInsertion() {
        // This test demonstrates the performance of regular insertion without batching.
        // It's expected to be slower due to individual insert calls for each entity.
        benchmark {
            transactionTemplate.execute {
                val stocks = (1..NUMBER_OF_STOCKS).map { Stock("TSLA$it", "Tesla") }
                stockRepository.persistAll(stocks)
            }!!
        }
    }
}

@SpringBootTest
@TestPropertySource(
    properties = ["spring.jpa.properties.hibernate.jdbc.batch_size=50"],
)
class InsertionPerformanceBatchingButNotWorking : BaseTestSetup() {
    @Test
    fun `batchedInsertion, but not really`() {
        // This test attempts to demonstrate batched insertion, but it won't work as expected.
        // It highlights the limitation with identity type IDs where batching is ineffective.
        // This is because the ID is generated by the database during the insert and returned after.
        // Notice how the insert statements in the logs do not have the ID column specified.
        benchmark {
            transactionTemplate.execute {
                val stocks = (1..NUMBER_OF_STOCKS).map { Stock("TSLA$it", "Tesla") }
                stockRepository.persistAll(stocks)
            }
        }
    }
}

@SpringBootTest
@TestPropertySource(
    properties = ["spring.jpa.properties.hibernate.jdbc.batch_size=50"],
)
class InsertionPerformanceBatchingWorking : BaseTestSetup() {
    @Test
    fun batchedInsertion() {
        // This now works because we are specifying the ID to use a sequence
        // so the ids are fetched before the insert occurs.
        // Notice how the ID fetching is also leveraging batching
        benchmark {
            transactionTemplate.execute {
                val stocks = (1..NUMBER_OF_STOCKS).map { StockWithSequence("TSLA$it", "Tesla") }
                stockWithSequenceRepository.persistAll(stocks)
            }
        }
    }
}

@SpringBootTest
@TestPropertySource(
    properties = ["spring.jpa.properties.hibernate.jdbc.batch_size=50"],
)
class InsertionPerformanceBatchingWorkingPool : BaseTestSetup() {
    @Test
    fun batchedInsertion() {
        // Using a SequenceGenerator we can use pooling to get a range of ids that are stored in memory
        // these ids can then be used for insert statements. Using a pooled sequence generator will lower the number
        // of round trips to the database to get the next id.
        // The trade-off is that the ids are stored in memory and if the application crashes or transaction rolls back
        // then the ids are lost, and there will be large gaps in the sequence in your table.

        benchmark {
            transactionTemplate.execute {
                val stocks = (1..NUMBER_OF_STOCKS).map { StockWithSequencePool("TSLA$it", "Tesla") }
                stockWithSequencePoolRepository.persistAll(stocks)
            }
        }
    }
}
